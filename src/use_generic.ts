import { useEffect, useId, useState } from 'react'
import { type SubscriberMiddlewareConstructor } from './subscriber_middleware'
import { type HookGeneratorOptions, type Subscriber } from './subscriber'

/**
 * This function implements a generic hook that can be used to implement any hook
 * generated by this library.
 */
export function useGeneric<Data, ErrorData, CompressedData, CompressedErrorData> (
  // The parameter that will be used to identify the subscriber, this is actually the only parameter
  // that the user will be able to pass to the hook
  parameter: string,
  // The subscriber pool that is used to store the dinamically generated subscribers classes for each parameter
  // loaded by the components.
  subscriberPool: Record<string, Subscriber<Data, ErrorData> | undefined>,
  // Initial subscriber class that will be used to generate the subscriber class
  SubcriberClass: new (parameters: string, options?: HookGeneratorOptions) => Subscriber<Data, ErrorData>,
  // Options to customize the subscriber class behavior
  subscriberOptions: HookGeneratorOptions,
  // Middleware class that will be used to generate the compressed data.
  subscriberMiddlewareClass: SubscriberMiddlewareConstructor<Data, ErrorData, CompressedData, CompressedErrorData>
): [data: CompressedData | null, error: CompressedErrorData | null, componentId: string] {
  const componentId = useId()

  // Tries to get the subscriber from the pool and retrieves the data and error from it if it exists
  const subscriber = subscriberPool[parameter]
  // The initial state of the hook is null, this will trigger a loading state on the component
  if (subscriber !== undefined) {
    subscriber.registerMiddleware<CompressedData, CompressedErrorData>(subscriberMiddlewareClass)
  }

  // We can initialize the hook from the subscriber cache if it exists
  const initialState = subscriber?.subscriberMiddlewares.get<CompressedData, CompressedErrorData>(
    subscriberMiddlewareClass
  )?.currentDataCache ?? { data: null, errorData: null }
  // We can optimize the useState function combine both CompressedData and ErrorData in one state, this wil reduce the
  // number of useState calls thus reducing the number of renders
  const [state, setState] =
        useState<{ data: CompressedData | null, errorData: CompressedErrorData | null }>({
          data: initialState.data,
          errorData: initialState.errorData
        })

  const data = state.data
  const errorData = state.errorData

  useEffect(() => {
    let mounted = true

    // Check if subscriber is parameters is already created
    let subscriber = subscriberPool[parameter]
    if (subscriber === undefined) {
      subscriber = new SubcriberClass(parameter, subscriberOptions)
      subscriberPool[parameter] = subscriber

      // Register the middleware in the subscriber if it does not exist already
      subscriber.registerMiddleware<CompressedData, CompressedErrorData>(subscriberMiddlewareClass)
    }

    const middleware = subscriber.subscriberMiddlewares.get<CompressedData, CompressedErrorData>(
      subscriberMiddlewareClass
    )

    if (middleware !== undefined && !middleware.observerFunctionMap.has(componentId)) {
      // Register the observer function in the middleware, so every time the middleware is notified it will call
      // this function to update the state of the component
      middleware.subscribe(componentId, (data, errorData) => {
        if (!mounted) {
          return
        }

        setState({ data, errorData })
      })
    }

    return function cleanup () {
      // Remove the observer function from the middleware
      middleware?.unsubscribe(componentId)

      // Mark the component as unmounted
      mounted = false
    }
  }, [componentId, parameter, subscriberPool, SubcriberClass, subscriberMiddlewareClass, subscriberOptions])

  return [data, errorData, componentId]
}
